

/*
 
LEETCODE -- 875

IN THIS WE ARE GIVEN THAT PILES OF BANANA SHOULD BE EATEN IN GIVEN TIME ON THE CONDITION THAT FIRST ONE PILE SHOULD BE 
FINISHED BEFORE GOING TO OTHER AND YOU CANNOT TAKE BANANAS FROM DIFFERENT PILES....FIRST FINISH FROM ONE AND THEN START OTHER 
MAX SPEED AT WHICH BANANAS CAN BE EATEN WOULD BE THE MAX ELEMENT....
SOLUTION-->
FIRST WE WILL FIND THE MAXIMUM ELEMENT FROM THE GIVEN ARRAY(PILES)...BECAUSE ANSWER WILL BE THE MAX ELEMENT OR LESS THAN IT 

WE WILL APPLY BINARY SEARCH HERE AND THE SEARCH SPACE WILL BE FROM 1 TO MAX ELEMENT OF ARRAY....FIND THE MID AND CHECK
THAT CAN IT BE A ANSWER IF YES THEN REDUCE THE SEARCH SPACE BY DECREASING LAST TO MID AND IF NO THEN REDUCE THE SEARCH
SPACE BY UPDATING START TO MID+1.....REPEAT THE SAME STEPS UNTILL BINARY SEARCH LOOP TERMINATES AND ANSWER WILL BE AT 
THE START INDEX
AS WE WANT THE MIN SPEED TO EAT THEREFORE WE WILL BE CHECKING FOR THE MIN ANSWER AT WHICH BANANS CAN BE EATEN IN THE GIVEN TIME

ONE LOPP WILL GIVE THE MAX ELEMENT THEN WE WILL USE THAT MAX ELEMENT AS A SEARCH SPACE AND APPLY BINARY SEARCH AND ON 
FINDING THE MID VALUE WE WILL CHECK USING A OTHER FUNCTION THAT WHETHER THE BANANAS AT MID SPEED CAN BE EATEN OR NOT, MEANS 
WILL BANANAS BE EATEN WITHIN THE TIME OR IT IS EXCEEDING THE TIME IF WITHIN THE TIME THEN UPDATE THE END INDEX AND IF NOT 
THEN UPDATE THE START INDEX OR WE CAN SAY THAT INCREASE OR DECREASE THE SPEED ON THE BASIS OF MID BY UPDATINF START AND END INDEXES


 */

class KokoEating{
    public static int MaxSpeed(int piles[],int h){
        int minSpeed = 1;
        int maxSpeed = 0;

        for(int pile:piles){
            maxSpeed = Math.max(pile,maxSpeed);
        }
        
        while(minSpeed < maxSpeed){
            int mid = minSpeed + (maxSpeed - minSpeed);
            if(canEat(piles,h,mid)){
                maxSpeed = mid;
            }
            else{
                minSpeed = mid+1;
            }
        }
        return minSpeed;
    }

    public static boolean canEat(int piles[],int h,int speed){
        int hours = 0;
        for(int pile:piles){
            hours += (int) Math.ceil((double) pile/speed);
        }
        return hours<=h;
    }

    
}